\documentclass[a4paper, 12pt]{article}

\usepackage[T1]{fontenc}

\usepackage{lipsum}
\usepackage{pifont}
\usepackage{amssymb}

\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{graphicx}
\graphicspath{ {./images/} }
\usepackage{spverbatim}
\usepackage{float}
\usepackage{url}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\usepackage{xstring}



\newcommand{\e}[1]{\emph{\StrSubstitute{#1}{_}{\_}}}
\newcommand{\Null}[0]{\e{NULL}}





\newcommand{\makesub}[1]{%
  \saveexpandmode\noexpandarg
  \StrSubstitute{#1}{\_}{_}[\temp]%
  \restoreexpandmode
}
\newcommand{\target}[1]{%
  \makesub{#1}%
  \hypertarget{\temp}{}%
}
\newcommand{\attach}[1]{%
  \makesub{#1}%
  \hyperlink{\temp}{\e{#1}}%
}


\newcommand{\func}[1]{%
	\attach{#1}%
}




\begin{document}\sloppy
  
\title{
  \textbf{
    \emph{Relazione homework 1}
  }
}  
\author{Luca Mastrobattista}
\date{}
\maketitle

\tableofcontents

\newpage
\section{Traccia dell'homework}
\subsection{Testo}
Analizzare con Ghidra, utilizzando lo strumento 
disassemblatore / decompilatore, il programma eseguibile
hw1.exe contenuto nell'archivio hw1.zip (password: "AMW21").
Riassumere in un documento tutte le informazioni acquisite
sul programma, con particolare riguardo alle strutture di
dati fondamentali utilizzate.
Descrivere anche la metodologia ed i passi logici deduttivi
utilizzati nel lavoro di analisi.
\subsection{Scadenza}
Due settimane dalla data di assegnazione del lavoro: 28/10/2021
\subsection{Consegna}
Documento in formato PDF inviato come allegato ad
un messaggio di posta elettronica all'indirizzo del docente
("$<$cognome$>$@uniroma2.it"), con subject:
"[AMW21] HW1: $<$matricola studente$>$"

\newpage
\section{Ambiente di lavoro}
Il file eseguibile è stato caricato su Ghidra istallato su un sistema operativo Linux. 

\newpage
\section{Metodologia}

\subsection{Informazioni note a priori}
Eseguibile ottenuto per l'esecuzione dell'homework e, quindi, non sono note informazioni preliminari.

\subsection{Finalizzazione dell'obiettivo}
Il reversing dell'applicazione ha come obiettivo quello di comprendere il funzionamento dell'eseguibile e di completare l'attività di e{reverse code engineering}, quindi l'obiettivo dello studio è la ricostruzione dell'intero programma.

\subsection{Ottenimento del codice macchina}
Codice macchina fornito dal professore.


\subsection{Osservazione del funzionamento}
Provando ad eseguire l'eseguibile su una macchina virtuale del sistema operativo Windows 10 non è stato ottenuto alcun output. Neanche nel gestore attività viene riportata alcuna informazione. L'applicazione sembra avviarsi e terminare in poco tempo.\newline

\begin{figure}[H]
\centering\includegraphics[width=\textwidth]{esecution}
\end{figure}

\subsection{Disassemblaggio del codice macchina}
Lo strumento che si è utilizzato è il software \emph{Ghidra}.

\subsubsection{Riepilogo risultati dell'import}
\begin{figure}[H]
\centering\includegraphics[width=\textwidth]{Import_Results_Summary}
\end{figure}

\subsubsection{Informazioni aggiuntive}
\begin{spverbatim}

----- Loading /home/luca/Scrivania/MA/homeworks/homework-01/hw1.exe ----- 
Delay imports detected... 
Searching for referenced library: ADVAPI32.DLL ... 
Unable to find external library: ADVAPI32.DLL 
Searching for referenced library: KERNEL32.DLL ... 
Unable to find external library: KERNEL32.DLL 
Searching for referenced library: MSVCRT.DLL ... 
Unable to find external library: MSVCRT.DLL 
Finished importing referenced libraries for: hw1.exe 
  [ADVAPI32.DLL] -> not found 
  [KERNEL32.DLL] -> not found 
  [MSVCRT.DLL] -> not found 
\end{spverbatim}

\newpage
\subsection{Ricerca del main}
\subsubsection{Ricerca tramite invocazioni di funzioni user}
Tentativo di ricerca del \e{main} sfruttando le invocazioni a funzioni di libreria. Nella libreria \e{MSVCRT.DLL} viene invocata la funzione \e{printf}. Cercando le referenze a quest'ultima, ne sono state trovate 7. Queste invocazioni sono tutte all'interno della stessa funzione, rinonimata da Ghidra con \func{FUN_004019a0_set_on_exit_actions}. Questa funzione, però, non può essere il nostro \e{main}: sappiamo infatti che nessuna \e{printf} è eseguita durante l'esecuzione del programma. Questo fatto lascia pensare che l'invocazione della funzione viene invocata in casi particolari dell'esecuzione, per esempio quando si verificano errori. In ogni caso, si può essere sicuri che questa funzione sia stata definita dal programmatore, e in questo modo è possibile risalire nel grafo delle invocazioni delle funzioni per arrivare al \e{main}.
\begin{figure}[H]
	\centering\includegraphics[scale=0.6]{main_ipotetic_tree}\newline
	 La funzione \func{FUN_00402a30_retrieve_and_print_key_info} è un buon canditato ad essere il main.
\end{figure}

Tuttavia, quella funzione prende in input 2 parametri, ma sono stati identificati entrambi come tipo \e{int}, mentre mi sarei aspettato di trovare un \e{undefined *} o qualcosa del genere come secondo parametro. 



\subsubsection{Ricerca tramite invocazioni di funzioni particolari}
Tra le funzioni di \e{MSVCRT.DLL}, c'è la funzione \e{__getmainargs}. Questa funzione richiama l'analisi della riga di comando e copia gli argomenti nel \emph{main()}. In particolare, questa funzione è invocata in \e{FUN_00401120_get_main_args} e gli vengono passati 5 paremetri. Questi, sono tutti variabili globali e rappresentano, in ordine:
\begin{itemize}
\item L'intero \emph{argc}
\item La amtrice di stringe \emph{argv}
\item Una matrice di stringe \emph{\_env} che rappresenta le variabili impostate nell'ambiente dell'utente.
\item Un intero che, e impostato su 1, espande i caratteri jolly negli argomenti della riga di comando o, se impostato su 0, non esegue alcuna operazione.
\item Un puntatore a \emph{\_startupinfo}, che contiene altre informazioni da passare alla DLL CRT.
\end{itemize}
La cosa interessante è che i primi due parametri sono passati in input anche alla funzione \func{FUN_00402a30_main}, che quindi è il nostro \emph{main}.

\begin{figure}[H]
\centering\includegraphics[width=\textwidth]{main_call_graph}
\end{figure}


\newpage
\section{Analisi con Ghidra}

\subsection{FUN\_00402a30\_main}
\target{FUN\_00402a30\_main}
Questa funzione, dopo aver fatto allineamento a 16 bytes, ne invoca subito un'altra: \func{FUN_004019a0_set_on_exit_actions}, analizzata in seguito.\\
Poi continua con dei controlli sulla riga comando: effettua \e{argv[argc]} e il risultato viene utilizzato per fare dei controlli. In particolare, se il valore così indicizzato è \Null, la funzione ritorna 0, altrimenti verifica il numero dei parametri passati: se è minore di 3, si imposta a \Null il valore dei primi 2 parametri a riga comando. Poi prepara l'invocazione di \e{MSVCRT.DLL::atoi}, che prende in input una stringa e ne restituisci il valore decimale rappresentato. La stringa data in input è il primo parametro a riga comando. Se il valore di ritorno è 0, si memorizza il valore della macro \e{HKEY_LOCAL_MACHINE} in \e{EAX}. Si continua controllando il secondo parametro a riga comando: se è \Null si salva in \e{EDX} il valore della stringa \emph{"SYSTEM\string\\ControlSet001\string\\Control"}. Questi due registri conterranno i parametri da passare all'invocazione di \func{FUN_004018a0_open_handle_to_reg_key}. Dopo l'invocazione, si controlla il valore ritornato dalla funzione: se è 0, termina, altrimenti salva questo valore nello stack e invoca la funzione \func{FUN_004018a0_open_handle_to_reg_key}. Quando quest'ultima termina, viene ritornato il valore 0.\\

Nota: il primo controllo che viene fatto è:
\begin{verbatim}
if (argv[argc] == (char *) 0)
    uvar4 = 0;
else{
	...
}
return uvar4	
\end{verbatim}
Ma la condizione dell'\emph{if} è sempre vera: infatti, se al programma sono dati \emph{argc} parametri, l' \emph{argc-esimo} sarà sempre \Null.




\subsection{FUN\_004019a0\_set\_on\_exit\_actions}
\target{FUN\_004019a0\_set\_on\_exit\_actions}

Nota per me: Utile analizzarla con il \emph{function graph}\bigskip

La funzione prende il valore della variabile globale \e{DWORD_00405020_one_time_control_label} e controlla se è 0: se non lo è, termina, altrimenti continua impostandolo a 1. Sembra quindi essere una variabile di controllo per evitare che questo codice venga eseguito più di una volta: infatti gli unici riferimenti a questa variabile sono all'interno di questa funzione. Dopodiché, controlla il valore di un'altra variabile, \e{DAT_00402ac0_my_struct}. In particolare, viene controllato se il suo valore è uguale a -1. Se non lo è, azzera il registro \e{EAX} con un'istruzione di xor, e inizia un ciclo. Ad ogni iterazione, il valore di \e{EAX} viene prima salvato in \e{EBX}, poi incrementato di 1, poi moltiplicato per 4 e infine viene usato come offset dal punto base fissato all'indirizzo di \e{DAT_00402ac0_my_struct}. Questo fatto lascia pensare che, in quell'indirizzo, sia memorizzata una struttura dati con componenti tutti della stessa taglia; potrebbe, a questo punto, essere anche un array di interi: sappiamo infatti che il primo elemento è stato confrontato col valore -1. \\
Il ciclo termina quando viene trovato un offset, multiplo di 4 byte, che indicizza \e{NULL} a partire da \e{DAT_00402ac0_my_struct}. Alla fine di questo ciclo, in \e{EBX} è memorizzato il numero di indirizzi diversi da \e{NULL} successivi a \e{DAT_00402ac0_my_struct}. Se questo valore è diverso da 0, cioè si è trovato almeno un indirizzo valido, parte un altro ciclo in cui vengono effettuate delle \emph{CALL}. Le funzioni invocate sono tutte quelle memorizzate negli indirizzi che sono diversi da \e{NULL} trovati precedentemente. \\
A questo punto, la nostra \emph{my\_struct} è definita:
\begin{figure}[H]
\centering\includegraphics[width=\textwidth]{my_struct}\\
\end{figure}
Il vettore di puntatori a funzioni è definito di dimensione 2 perché è il minimo valore che permette di avere una funzione da invocare e il \Null per indicarne la fine. A questo punto dell'analisi non è nota la sua dimensione reale. Inoltre, la struttura dati all'indirizzo \e{DAT_00402ac0_my_struct}, contiene un intero al primo campo, l'indirizzo della funzione \func{FUN_00401500_in_my_struct}, e poi un \Null : effettivamente l'array ha solo 2 elementi. \\

Quando queste invocazioni terminano e il ciclo finisce, la funzione inserisce l'indirizzo di una funzione nello stack (\func{FUN_00401900_given_to_set_before_exit}), alla posizione \e{-0x1c} e invocherà poi \func{FUN_004014e0_set_before_exit} prima di terminare.\\

Nota: lo stack pointer viene cambiato come prima istruzione di \func{FUN_004014e0_set_before_exit}, quindi il primo parametro di quella funzione corrisponderà a questo indirizzo.



\subsection{FUN\_00401500\_in\_my\_struct}
\target{FUN\_00401500\_in\_my\_struct}
Questa funzione era marcata come \e{UndefinedFunction} dal decompilatore ed è è l'unica funzione presente nell'istanza di \e{my_struct} all'indirizzo \e{DAT_00402ac0_my_struct}. L'unica cosa che fa è invocare \func{FUN_004014e0_set_before_exit}, a cui viene passato in input il valore di \e{DAT_00401520}. Poiché, come vedremo, \func{FUN_004014e0_set_before_exit} prende in input un puntatore a funzione, possiamo dedurre che il valore della variabile \e{DAT_00401520} è un puntatore a funzione.\\

\textbf{Problema}: convertendo la variabile \e{DAT_00401520} in tipo di dato \emph{pointer}, viene indicizzato un indirizzo che non è presente nell'address space. Tuttavia questo valore è passato a \e{_onexit}, che prende in input un puntatore a funzione e deve necessariamente essere un puntatore a funzione.


\subsection{FUN\_00401900\_given\_to\_set\_before\_exit}
\target{FUN\_00401900\_given\_to\_set\_before\_exit}

Questa funzione, per prima cosa, carica un indirizzo dentro il registro \e{EAX}. Questo indirizzo, chiamato \e{PTR_PTR_00403004}, è un puntatore doppio. Infatti, subito dopo, viene preso l'indirizzo puntato e caricato ancora in \e{EAX}. Si controlla quindi se l'indirizzo è \Null{}. Se lo è, termina, altrimenti inizia poi un ciclo che, come prima istruzione, prevede una \e{CALL} all'indirizzo memorizzato in \e{EAX}, cioè il valore appena controllato. Di conseguenza, il valore puntato da \e{PTR_DAT_00403004} è un puntatore a funzione. \\
Nelle iterazioni si sposta di 4 bytes in avanti rispetto alli'indirizzo appena usato nella call e, se non è \Null{}, procede con la sua invocazione. Si sta praticamente scorrendo un ipotetico array di puntatori a funzioni. Il ciclo termina quando viene trovato un puntatore a \Null{}, che non può essere usato nella \e{CALL}. Quando il ciclo termina, la funzione ritorna.\\

\target{Nota}
Nota: il primo controllo che viene fatto è che l'indirizzo base puntato da \e{PTR_PTR_00403004} non sia \Null{}, ma nel codice questo puntatore punta proprio a \Null{}. La funzione dovrebbe quindi terminare semplicemente, senza fare altro.


\subsection{FUN\_004014e0\_set\_before\_exit}
\target{FUN\_004014e0\_set\_before\_exit}
Questa funzione invoca al suo interno la funzione di libreria \e{MSVCRT.DLL::_onexit}. Questa funzione prende in input un puntatore alla funzione che deve essere invocata prima che il programma termini, una sorta di \e{wrapper} per l'evento di uscita. In caso di più invocazioni di questa funzione, l'ordine di esecuzione delle varie funzioni è quello \emph{LIFO}: infatti la documentazione riporta il seguente esempio:
\begin{verbatim}

#include <stdlib.h>
#include <stdio.h>

/* Prototypes */
int fn1(void), fn2(void), fn3(void), fn4 (void);

int main( void )
{
   _onexit( fn1 );
   _onexit( fn2 );
   printf( "This is executed first.\n" );
}

int fn1()
{
   printf( "executed next.\n" );
   return 0;
}

int fn2()
{
   printf( "This is " );
   return 0;
}

\end{verbatim}
L'output è: 
\begin{verbatim}
This is executed first.
This is executed next.
\end{verbatim} \bigskip 

È utile quindi ricercare tutti i punti in cui questa funzione viene invocata. Ci sono solo 2 riferimenti, entrambi nella funzione \func{FUN_004019a0_set_on_exit_actions}: uno è diretto, l'altro invece è nascosto: si invoca tramite la struttura dati \e{my_struct}
\begin{figure}[H]
\centering\includegraphics[scale=0.4]{set_before_exit} \\
Nota: la funzione \func{FUN_00401500_in_my_struct} compare 2 volte perchè la prima, quella evidenziata nell'immagine, è una \emph{Thunk}.
\end{figure} \bigskip

Prima di terminare l'applicazione, quindi, le funzioni verrano eseguite nel seguente ordine:
\begin{enumerate}
\item \func{FUN_00401500_in_my_struct}, che però utiliza un indirizzo non presente nell'address space: \e{PTR_DAT_00401520} ha come valore \e{DAT_909090c3}, segnato in rosso da Ghidra.
\item \func{FUN_00401900_given_to_set_before_exit}, che però, come detto, nella \func{Nota}, dovrebbe terminare subito.
\end{enumerate} \bigskip

Concludendo, nessuna funzione viene impostata come \emph{wrapper} per l'evento di \emph{exit}.



\subsection{FUN\_004018a0\_open\_handle\_to\_reg\_key}
\target{FUN\_004018a0\_open\_handle\_to\_reg\_key}
Questa è un'altra funzione invocata da \emph{main} che, per prima cosa, azzera il registro \e{EBX}, poi prepara l'invocazione di \e{ADVAPI32.DLL::RegOpenKeyExA}. Questa funzione prende in input i seguenti parametri:
\begin{enumerate}
\item un \e{HKEY}, passato in input alla funzione;
\item un \e{LPCSTR}, anche questo dato in input alla funzione
\item un \e{DWORD}, che in questo caso è 0;
\item un \e{REGSAM}, una maschera di bit che rappresenta i diritti di accesso, e in questo caso è impostato a \e{0xf003f} che corrisponde a \e{KEY_ALL_ACCESS};
\item un \e{PHKEY}, un puntatore che riceve l'handle verso la key aperta.
\end{enumerate} 
Quando la funzione ritorna, si controlla il suo valore di ritorno: infatti, se tutto è andato bene, ritorna il valore 0, corrispondente a \e{ERROR_SUCCESS}. Se in \e{EAX} c'è effettivamente il valore 0, si mette sullo stack l'handle verso la key aperta e si invoca \func{FUN_00401530_retrieve_subkeys_and_values}. Il valore di ritorno di questa funzione si memorizza in \e{EBX}. Poi si invoca \e{ADVAPI32.DLL::RegCloseKey}, passandogli come parametro l'handle verso la key ottenuto precedentemente, in modo da chiuderlo. Infine, la funzione termina restituendo il valore contenuto in \e{EBX}, che sarà \Null{} se c'è stato un errore oppure il risultato di \func{FUN_00401530_retrieve_subkeys_and_values}. \bigskip

Riassumendo: si apre il registry key path dato da riga comando; se non viene passato nulla, il default è impostato a: \verb+HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control+. Si invoca poi  \func{FUN_00401530_retrieve_subkeys_and_values}, il cui valore di ritorno viene effettivamente ritornato al \verb+main+.


\subsection{FUN\_00401530\_retrieve\_subkeys\_and\_value}
\target{FUN\_00401530\_retrieve\_subkeys\_and\_value}
La prima cosa che fa questa funzione è allocare 52 bytes con un'invocazione di \e{MSVCRT.DLL::malloc}. Quindi viene controllato il valore di ritorno di questa invocazione e, se è 0, viene invocata una \e{MSVCRT.DLL::puts} per stampare la stringa \e{"Memory allocation error"} prima di terminare con una chiamata a \e{MSVCRT.DLL::exit}, con \emph{exit code} pari a 1.\\
Se le cose vanno bene, invece, si salva il valore ritornato dentro il registro \e{EBX}. Si invoca poi una nuova \e{malloc} per allocare 260 bytes. Anche qui, si controlla il valore di ritorno e si eseguono le stesse istruzioni dell'invocazione precedente nel caso questo sia 0. \\
Se anche la seconda \e{malloc} va a buon fine, l'indirizzo di ritorno viene salvato come valore dell'indirizzo restituito dalla prima invocazione. \\

Si è ottenuto quindi che la prima \e{malloc} alloca 60 bytes e, il valore dei primi 4 sarà l'indirizzo restituito dalla seconda:
\begin{figure}[H]
\centering\includegraphics[scale=0.4]{malloc_invocations}\\
In \e{Addr_1}, che è l'indirizzo a cui punta \e{EBX}, è memorizzato un puntatore ad \e{Addr_2}
\end{figure} 

In seguito, viene salvato in \e{EDX} il valore contenuto all'offset 32 con base \e{EBX}; supponendo sia un array di puntatori, si prende l'ottavo.\\
Poi c'è una cosa interessante: la zona di memoria puntata da \e{EAX}, che conserva ancora l'indirizzo restituito dalla seconda \e{malloc}, viene inizializzata a un \e{byte ptr} con valore 0; si sta settando quell'area di memoria a \verb+'\0'+. \\
Si procede caricando in \e{ECX} il valore contenuto in \e{EBX+36}: si sta memorizzando il nono elemento. Nell'area puntata da \e{EBX+4} si memorizza il valore 260, in quella puntata da \e{EBX+8} il valore 0. \\

\target{ipotesi}
Ipotesi: sembra che, quella puntata da \e{EBX}, sia una struttura dati in cui il primo campo memorizza un buffer, il secondo la sua grandezza e il terzo i byte effettivamente usati.\\

Il codice continua preparando l'invocazione della funzione
\e{ADVAPI32.DLL::RegQueryInfoKeyA}: vengono messi sullo stack i seguenti parametri (riporati qui nell'ordine in cui li vede la funzione invocata):
\begin{enumerate}
\item Il primo parametro passato a questa funzione. La documentazione dice che questo è, infatti, l'\emph{handle} verso un registro aperto.
\item Il puntatore al buffer. Questo parametro è opzionale: è un \e{LPSTR} che punta a un buffer che riceve la classe della chiave.
\item Il valore memorizzato in \e{EBX+4}, cioè 260, la dimensione del buffer allocato con la seconda \e{malloc}. Questo è un \e{LPDWORD} che punta a una variabile contenente la dimensione del buffer passato come parametro precedente, come da \func{ipotesi}.
\item Il valore 0. Questo campo è riservato e deve essere \e{NULL}.
\end{enumerate}
\begin{itemize}
\item I byte che vanno da \e{EBX+8} a \e{EBX+32}: sono 6 elementi di 4 bytes ciascuno. Sono infatti 6 \e{LPDWORD} che memorizzano, in ordine: 
	\begin{enumerate}
	 \setcounter{enumi}{4}
	\item Un puntatore a una variabile che riceve il numero di sotto-chiavi contenute nella chiave specificata. Non è, come si pensava nell'\func{ipotesi}, il numero di bytes utilizzati.
	\item Un puntatore a una variabile che riceve la dimensione della sotto-chiave con il nome più lungo, senza il terminatore di stringa
	\item Un puntatore a una variabile che riceve la dimensione della stringa più lunga che specifica una classe, anche qui senza terminatore di stringa.
	\item Un puntatore a una variabile che riceve il numero di valori associati alla chiave passata.
	\item Un puntatore a una variabile che riceve la dimensione del nome più lungo tra tutti i valori associati alla chiave.
	\item Un puntatore a una variabile che riceve la dimensione del componente dati più grande tra tutti i valori associati alla chiave, espresso in bytes.
	\end{enumerate}
\end{itemize}
\begin{enumerate}
\setcounter{enumi}{10}
\item il valore di \e{EBX+32}. Questo è un \e{LPDWORD} e punta a una variabile che riceve la dimensione del \emph{security descriptor} della chiave, in bytes.

\item il valore contenuto nella zona di memoria puntata da \e{EBX+36}. Questo parametro è un \e{PFILETIME}, che punta a una struttura che riceve l'ultimo istante di tempo in cui la chiave o uno dei suoi valori è stato modificato. Di conseguenza, in \e{EBX+36} è memorizzata una struttura \e{FILETIME}.

\end{enumerate}

Si può quindi definire una struttura dati di 52 byte, che chiamiamo \e{all_subkey_info_keeper}. Questa struttura avrà i seguenti campi, in ordine: 
\begin{enumerate}
\item Un puntatore a un buffer
\item La dimensione del buffer del campo 1
\item Un puntatore al numero delle sotto-chiavi contenute nella chiave passata
\item Un puntatore alla dimensione della sotto-chiave più lunga
\item Un puntatore alla dimensione della classe più lunga
\item Un puntatore al numero di valori associati alla chiave
\item Un puntatore alla dimensione del componente dati più grande tra quelli di tutti i valori
\end{enumerate}
Rimangono ancora altri bytes da definire. \\

Quando la funzione ritorna, si controlla il valore di ritorno: se non è 0, viene stampata la stringa \e{"RegQueryInfoKey failed: key not found"} tramite la funzione \e{MSVCRT.DLL::puts} e viene poi ritornato il valore 0.\\
Se la funzione ha avuto successo, invece, si controlla il terzo campo della struttura, e cioè il numero di sotto-chiavi. \\
Se questo valore non è 0 inizia un ciclo che, come prima istruzione, alloca 16 bytes con la funzione \e{malloc}; si salva il valore di ritorno nel registro \e{EBP} e si controlla il suo valore. \\

Nota: i valori restituiti da \e{malloc} sono salvati tutti: in \e{EBX} c'è il primo, ed è la struttra dati di tipo \e{all_subkey_info_keeper}; nel primo campo di \e{EBX} c'è il buffer; e infine questi 16 bytes sono salvati in \e{EBP}. \\

Se \e{malloc} fallisce, l'esecuzione termina con codice di uscita 1, stampando il messaggio di errore \e{"Memory allocation error"}. Se tutto va bene, invece, si inizializza il valore dei bytes allocati. \\

Nota: anche questa sembra una struttura dati. A suggerirlo è il fatto che vengono inizializzati gli indirizzi ottenuti con un offset a partire dall'indirizzo base restituito da \e{malloc}. I campi vengono inizializzati nel seguente modo: 
\begin{enumerate}
\item I primi bytes si fanno puntare alla struttura precedente, quella di tipo \e{RegQueryInfoKey_helper_struct} memorizzata in \e{EBX}
\item Un puntatore a \Null{}
\item \e{Non ancora definito}
\item Il valore del puntatore a \emph{maxSubKeyLen}
\end{enumerate} 
Questa struttura dati, come detto, viene memorizzata in \e{EBP}, e viene rinonimata in \e{helper_retrieve_subkeys}. \bigskip

Il codice continua invocando ancora \e{malloc} e il numero di byte da allocare è pari a \emph{maxSubKeyLen}. Come al solito, si controlla se la funzione ha avuto successo e in caso di fallimento termina l'esecuzione dell'applicazione.\\
Il valore di ritorno viene memorizzato nel terzo campo della struttura in \e{EBP}, ma anche sullo stack, nella variabile \e{local_54}. Il riferimento alla struttura dati in \e{EBP} viene salvato anche in \e{EDI}. Il terzo campo, quindi, è un puntatore a un'area di memoria della dimensione specificata nel quarto campo, cioè \e{maxSubKeyLen}. \\
Si prepara l'invocazione della funzione \e{ADVAPI32.DLL::RegEnumKeyExA}, inserendo sullo stack i seguenti valori:
\begin{enumerate}
\item Il primo parametro della funzione, cioè l'handle al registro aperto.
\item Il valore del registro \e{ESI}, impostato precedentemente a 0. Questo valore è un \e{DWORD} che rappresenta l'indice della sottochiave da recuperare. Nella prima invocazione di questa funzione, questo parametro deve essere 0, mentre deve essere poi incrementato per invocazioni successive.
\item Il buffer di \emph{maxSubKeyLen} bytes memorizzato al terzo campo della struttura in \e{EBP}. Infatti questo è un puntatore a un buffer che riceve il nome della sotto-chiave, includendo il terminatore di stringa.\\
Nota: la funzione precedente restituiva in questo campo la lunghezza della string apiù lunga \textbf{senza} terminatore. È un bug?
\item Il quarto campo della struttura di tipo \e{struct}, che rappresenta il puntatore alla dimensione del buffer e, in questo caso, vale \emph{maxSubKeyLen}. La documentazione prevede infatti un pointer a una variabile che specifica la dimensione del buffer passato nel parametro precedente.
\item Il valore 0. Parametro riservato: come da documentazione, è \e{NULL}.
\item Il valore 0. Qui si può avere \e{NULL} oppure un puntatore a un buffer che riceve una classe della sotto-chiave definita dall'utente.
\item Il valore 0. Anche qui si può avere \e{NULL}. Se, però, nel parametro precedente c'è un buffer, qui va inserita la sua dimensione.
\item Il puntatore \e{PFILETIME} alla struttura ritornata da \e{RegQueryInfoKeyA}. Questa struttura verrà sovrascritta senza essere mai stata letta, perché verrà inserito l'istante in cui la sotto-chiave è stata scritta l'ultima volta.
\end{enumerate}

Si controlla il valore di ritorno della funzione: se tutto è andato bene, si incrementa il contatore \e{ESI}: infatti questo registro è usato come secondo parametro di \e{RegEnumKeyExA} e, come detto, deve essere un valore incrementale per indicizzare le varie sotto-chiavi, e può essere interpretato come un indice che parte da 0. Si effettua quindi il confronto tra il valore del campo \emph{subKeysNumber} della struttura dati in \e{EBX} questo valore incrementato. Se \emph{subKeysNumber} è minore o uguale al contatore, si esce, perché tutte le chiavi sono state controllate, altrimenti si riparte col ciclo. Se c'è stato un errore, e quindi il valore di ritorno è diverso da 0, si salva il valore contenuto in \e{EBP+0x4} nel registro \e{EDI} e ci si prepara a un'invocazione della funzione \e{MSVCRT.DLL::free}: si prende il valore di \e{EBP}, che punta a un indirizzo ritornato da \e{malloc} ed è il puntatore alla struttura dati \e{struct} e lo si mette sullo stack, in modo da passarlo a \e{free}. Prima della sua invocazione, si incrementa il valore di \e{ESI}.\\

Nota: quando le cose vanno bene, il ciclo ricomincia con \e{EDI} impostato al valore di \e{EBP}, cioè al valore dell'istanza corrente della struttura dati. All'iterazione successiva, viene allocata una istanza della struttura. Il secondo campo, viene impostato a \e{EDI}, cioè all'istanza precedente. Si sta quindi costruendo una lista collegata. \\
Quando le cose vanno male, invece, l'attuale istanza della classe non è inclusa nella catena, e viene anzi rilasciata. Il registro \e{EDI} viene impostato al valore dell'istanza creata all'iterazione precedente: si sta escludendo l'istanza attuale dalla catena.

Dopo la \e{free}, si confronta il valore del campo \emph{subKeysNumber} della struttura dati in \e{EBX} con il valore di \e{ESI}, quindi dell'indice incrementato. Se \emph{subKeysNumber} è maggiore stretto, si riparte con il ciclo, altrimenti si esce. \\

Una volta usciti dal ciclo, si memorizza nella struttura dati di \e{EBX}, all'offset 44, il valore di \e{EAX}: attualmente, in \e{EAX} è salvato il valore di \e{EDI}, che contiene la base della lista collegata.

Se invece nel ciclo non ci si entra proprio, perché il valore di \emph{subKeyNumber} restituito dalla funzione \e{RegQueryInfoKeyA} è pari a 0, allora si memorizzerà il valore \e{NULL}. Poi c'è un controllo sul campo \emph{valuesNumber} della struttura dati \e{all_subkey_info_keeper}.\\

Nota: prima sono state controllate tutte le sotto-chiavi, adesso sta preparando il controllo su tutti i valori associati alla sotto-chiave.\\

Se il numero dei valori non è 0 inizia un ciclo, dove, per prima cosa, vengono allocati con \e{malloc} la bellezza di 16660 bytes, che corrispondono a circa 16 Megabites e l'indirizzo di ritorno viene memorizzato in \e{EBP}; Ovviamente c'è un controllo sul valore restituito e, in caso di errore, si termina mostrando la solita stringa \emph{"Memory allocation error"}. \\

Nota: suppongo che anche questa sia una struttura dati.\\

Viene memorizzato all'offset 4 il valore di \e{ESI}, che contiene inizialmente il valore 0, ma poi conterrà l'istanza della struttura creata all'iterazione precedentemente. In seguito si imposta come primo valore il valore di \e{EBX}, cioè il puntatore alla prima struttura dati allocata, quella di tipo \e{all_subkey_info_keeper}. Si memorizza poi all'offset 16392 il valore 16383, mentre all'offset 8 si inizializza il terminatore di stringa. Si inserisce all'offset 16656 il valore 256; si sono inizializzati i suoi campi. \\
Se il valore ritornato da malloc non è \e{NULL}, si prepara l'invocazione di \e{ADVAPI32.DLL::RegEnumValueA}: vengono passati sullo stack i seguenti parametri:
\begin{enumerate}
\item Il parametro della funzione, cioè l'handle alla chiave.
\item Il valore 0, contenuto nel registro \e{EDI}. Questo è come il parametro 2 della chiama a \e{RegEnumKeyExA}: è un valore incrementale che indicizza il valore da recuperare.
\item L'indirizzo dell'offset 8 a partire dall'indirizzo allocato con malloc. Rappresenta un buffer che riceve il nome del valore. Include il terminatore di stringa.
\item L'indirizzo dell'offset \emph{16392} a partire dall'indirizzo allocato con malloc. Puntatore a un'area di memoria contenente la dimensione del buffer precedente, ma non include il terminatore di stringa. In questo campo è memorizzato il valore \emph{16383}, quindi all'offset 8 è contenuto un buffer di \e{16834} caratteri. Torna con ciò che è stato inserito nella struttura precedentemente.
\item Il valore 0. Parametro riservato e deve essere \e{NULL}
\item L'indirizzo dell'offset \emph{16396}. Puntatore a una variabile che riceve un codice che indica il tipo di dato memorizzato nel valore specificato.
\item L'indirizzo dell'offset \emph{16400}. Puntatore a un buffer che riceve i dati relativi al valore.
\item Il valore all'offset \emph{16656}, che contiene il valore \e{256}. Puntatore a una variabile che specifica la dimensione del buffer precedente, in bytes. Quindi l'allocazione di memoria all'offset \e{16400} è un buffer di \e{256} bytes. 
\end{enumerate} 

La struttura dati ha la seguente forma:
\begin{figure}[H]
\centering\includegraphics[width=\textwidth]{helper_retrieve_values}
\end{figure}

Quando l'invocazione ritorna, si controlla il suo valore di ritorno. Se è andato tutto bene, il valore \e{EDI}, che è l'indice del valore che viene recuperato, viene incrementato di 1; si controlla quindi che questo valore non sia maggiore del campo all'offset \emph{20} di \e{EBX}, cioè \emph{valuesNumber}. Se il contatore è minore, si riparte nel ciclo, altrimenti si esce. \\
Se invece il valore di ritorno è diverso da zero, si salva il valore di \e{EBP+0x4} nel registro \e{ESI} prima di inserire \e{EBP} sullo stack per invocare la \e{free}: in questo modo si esclude dalla lista collegata l'istanza attuale, che ha generato errore. Si continua poi incrementando il contatore e facendo il controllo nescessario a determinare se uscire dal ciclo o meno.\\

Una volta usciti dal ciclo, si memorizza il valore salvato nel registro \e{ESI}, che contiene la lista collegata dei valori relativi alla chiave passata, all'interno dell'offset \emph{0x30} di \e{EBX}, che memorizza la struttura dati di tipo \e{RegQueryInfoKey_ helper_ struct}.\\

La funzione ritorna il valore di \e{EBX}, ossia la struttura dati di tipo \e{all_subkey_info_keeper}.\\

Le strutture dati, al termine della funzione, sono così definite:
\begin{figure}[H]
\centering\includegraphics[width=\textwidth]{all_subkey_info_keeper} \\
\end{figure}
\begin{figure}[H]
\centering\includegraphics[width=\textwidth]{helper_retrieve_subkeys}\\
\end{figure}
\begin{figure}[H]
\centering\includegraphics[width=\textwidth]{helper_retrieve_values}\\

\end{figure}

Riassumendo: la funzione esplora la chiave passata in input per cercare i valori e le sotto-chiavi ad essa collegate. Memorizza il tutto in una struttura dati che viene poi ritornata.

















\subsection{UndefinedFunction\_00402ab0 - Pt.1}
\target{UndefinedFunction\_00402ab0 - Pt.1}
La funzione viene invocata tramite un'istruzione di salto nella funzione \func{FUN_00402a30_retrieve_and_print_key_info}. Questa funzione viene invocata direttamente da \emph{entry}: conviene quindi analizzarla per prima. 
 













\subsection{FUN\_004019e0\_get\_system\_info}
\target{FUN\_004019e0\_get\_system\_info}

È interessante analizzare questa funzione, invocata da \e{entry} perché ci da informazioni su una interessante struttura dati. Questa funzione invoca \e{KERNEL32.DLL::GetSystemTimeAsFileTime}, che prende in input un parametro. Questo parametro è un pointer a una struttura di tipo \e{FILETIME}, che verrà riempita con data e ora di sistema in formato UTC. Il parametro passato a questa funzione è l'indirizzo della variabile \e{local_2c}. Possiamo dunque concludere che questa variabile è di tipo \e{FILETIME}. Questa struttura dati rappresenta il numero di intervalli di 100-nanosecondi trascorsi dal 1$^o$ Gennaio 1601 ed ha 2 campi, che sono:
\begin{itemize}
	\item \e{dwLowDateTime}: bit meno significativi
	\item \e{dwHighDateTime}: bit più significativi
\end{itemize}
Questi campi vengono usati come input per un'operazione di \e{XOR}, il cui risultato viene salvato in \e{EBX} prima di procedere con altre invocazioni.\\
In seguito, c'è un'invocazione della funzione \e{KERNEL32.DLL::GetCurrentProcessId}, che ritorna un \e{DWORD} contenente l'id del processo corrente. Questo valore viene salvato nel registro \e{EBP} prima di invocare \e{KERNEL32.DLL::GetCurrentThreadId}, che invece ritorna l'id del thread chiamante. Questo valore viene invece salvato nel registro \e{EDI}.\\
In seguito, viene invocato \e{KERNEL32.DLL::GetTickCount}, che ritorna il numero di millisecondi trascorsi da quando il sistema è stato avviato. Questo valore è salvato in \e{ESI}.\\
Andando ancora oltre, viene invocata \e{KERNEL32.DLL::QueryPerformanceCounter}. Questa funzione prende in input un puntatore a \e{LARGE_INTEGER}. Nel codice, gli viene passato in input, tramite registro, a \e{local_24}, che quindi è di tipo \e{LARGE_INTEGER}. Al termine dell'esecuzione, questo parametro conterrà il numero di cicli di clock (non è ben chiaro da quando vengono contati, ma suppongo dall'accensione del pc). \\
Ci sono poi molte operazioni di \e{XOR} di cui non riesco a capire il senso.

\subsection{tls\_callback\_0}
\target{tls\_callback\_0}

\subsection{FUN\_00402480\_critical\_section\_manager}
\target{FUN\_00402480\_critical\_section\_manager}

Questa funzione viene invocata sia da \e{tls_callback_0} che da \e{tls_callback_1} e prende in input 2 paramtri, entrambi di 4 bytes. La prima cosa che fa è controllare se il secondo parametro, \e{param_2}, sia uguale a 2 e, nel caso lo fosse, invoca la funzione \func{FUN_00401cb0_initialize_floating_point_unit_func}, e poi ritorna. In caso contrario, continua a controllarne il valore. In particolare, controlla se \e{param_2} è minore di 3. Se lo è, distingue 2 casi: 
\begin{itemize}
\item \e{param_2 == 0}: si controlla il valore della variabile globale \e{DAT_004053b4_contatore_critical_section}: se è diversa da 0, viene invocata \func{FUN_00402300_scan_address_space}. Il codice continua prendendo il riferimento al puntatore \e{DAT_004053b4_contatore_critical_section} e si verifica che sia uguale a 1. Se lo è, inizia un ciclo while al cui interno c'è un'invocazioni di \e{free} su indirizzi della forma:
\[
	memory = my\textunderscore hidden\textunderscore structure\textunderscore pointer + k * 8	 \qquad k \geq 0
\]
Il ciclo si interrompe quando l'indirizzo ottenuto sarà \e{NULL}. Al termine del ciclo, \e{my_hidden_structure_pointer} viene portato a \e{NULL}, \e{DAT_004053b4_contatore_critical_section} viene re-inizializzato a 0 e le risorse in sezione critica vengono rilasciate con l'invocazione di \e{KERNEL32.DLL::DeleteCriticalSection}.

\item \e{param_2 != 0}: si controlla il valore di \e{DAT_004053b4_contatore_critical_section} e, se vale 0, inizializza una nuova sezione critica, impostando a 1 il valore della variabile contatore.
\end{itemize}
Nel caso in cui, invece, \e{param_2} sia maggiore o uguale di 3, si controlla che \e{DAT_004053b4_contatore_critical_section} sia diverso da 0 e che \e{param_2} sia uguale a 3. In caso siano entrambe vere si invoca la funzione \func{FUN_00402300_scan_address_space}.\bigskip

Riassumendo, la funzione cambia il suo flusso di esecuzione in base al paremtro passato. Potrebbe essere riscritta in modo più chiaro utilizzando uno \e{switch}:
\begin{verbatim}
undefined4 __cdecl FUN_00402480_under_test(dword param_1,uint param_2)

{
  void *pvVar1;
  void *_Memory;
  
  switch(param_2){
    case 0:
      if (DAT_004053b4_contatore_critical_section != 0) {
        FUN_00402300_scan_address_space();
      }
      _Memory = _my_hidden_structure_pointer;
      if (DAT_004053b4_contatore_critical_section == 1) {
        while (_Memory != (void *)0x0) {
          pvVar1 = *(void **)((int)_Memory + 8);
          free(_Memory);
          _Memory = pvVar1;
        }
        _my_hidden_structure_pointer = (void *)0x0;
        DAT_004053b4_contatore_critical_section = 0;
        DeleteCriticalSection(
        	(LPCRITICAL_SECTION)&DAT_004053b8_critical_section_data
        	);
      }
      break;
    case 1:
      if (DAT_004053b4_contatore_critical_section == 0) {
        InitializeCriticalSection(
        	(LPCRITICAL_SECTION)&DAT_004053b8_critical_section_data
        	);
      }
      DAT_004053b4_contatore_critical_section = 1;
      break;
      
    case 2:
      FUN_00401cb0_initialize_floating_point_unit_func();
      break;
    case 3:
      if (DAT_004053b4_contatore_critical_section != 0) {
        FUN_00402300_scan_address_space();
      }
      break;
  return 1;
\end{verbatim}

Avendo capito che il \e{param_2} determina il flusso di esecuzione, lo si può rinonimare in \e{control_cmd}.

\subsection{FUN\_00402300\_scan\_address\_space}
\target{FUN\_00402300\_scan\_address\_space}

In questa funzione viene invocata una chiamata a \e{KERNEL32.DLL::EnterCriticalSection}, che prende come parametro un \e{LPCRITICAL_SECTION}, puntatore a un oggetto di tipo \e{CRITICAL_SECTION}. Questa invocazione mette in attesa il processo finché non gli viene garantito l'ingresso atomico in sezione critica. Gli viene passato come parametro l'idirizzo della variabile globale \e{DAT_004053b8_critical_section_data}, che quindi sarà proprio di tipo \e{CRITICAL_SECTION}. Dopo la chiamata alla funzione, il codice procede con un loop. La prima istruzione del loop è un'invocazione a \e{KERNEL32.DLL::TlsGetValue}, che prende in input un indice che, secondo la documentazione, deve essere allocato da una chiamata a funzione \e{TlsAlloc}. Nel codice, però, questa funzione non viene mai invocata, e il valore dato in input viene inizializzato a 0 o a 1 nella funzione \func{FUN_00402480_critical_section_manager}: questi sono gli unici punti in cui la variabile viene scritta. Se l'invocazione ha successo, viene ritornato il valore memorizzato nello slot del TLS del processo chiamante associato con l'indice specificato.\\
Dopo aver invocato \e{TlsGetValue}, viene invocata la funzione \e{KERNEL32.DLL::GetLastError} per verificare se la funzione precedente è andata a buon fine oppure no. La documentazione afferma che, se la \e{TlsGetValue} ritorna 0, si deve controllare che anche il valore ritornato da \e{GetLastError} sia 0, che corrisponde al codice \e{ERROR_SUCCESS}. Questo è ciò che fa in seguito il codice: controlla che \e{GetLastError} abbia ritornato 0 e che \e{TlsGetValue} non abbia ritornato 0. Se queste condizioni non sono entrambe vere, allora si procede con:
\begin{verbatim}
	MOV EBX, dword ptr [EBX + 0x8]
	TEST	 EBX EBX
	JNZ <label_di_inizio_loop> ; Ricomincia il ciclo
\end{verbatim}
Ora: in \e{EBX} è memorizzato il \e{my_hidden_structure_pointer} che, come detto, è inizializzato a 0. Partendo quindi dall'indirizzo \e{0x0} cerca un \e{DWORD} da passare in input alla funzione \e{TlsGetValue} tale che la funzioni non abbia errori, scandendo l'address space ma non controllando tutti gli indirizzi: ogni incremento è tale da aumentare l'indirizzo di 8 bytes. Quindi, dato un indirizzo, si controllano i primi 4 bytes e, in caso di valore invalido, si aumenta l'indirizzo di 8 bytes, non di 4. Questo fatto lascia pensare che si stia cercando una struttura dati con 2 campi da 4 bytes ciascuno, contenente un \e{TlsIndex} come primo campo e un puntatore a funzione come secondo. Quando si trova un indice valido, infatti, vengono eseguite le seguenti istruzioni:
\begin{verbatim}
	MOV EAX, dword ptr [EBX + 0x4]
	MOV dword ptr [ESP], ESI
	CALL EAX
\end{verbatim}
Si è certi di aver trovato l'indirizzo a 32 bits di un \e{TlsIndex} valido, ed è memorizzato in \e{EBX}; questo valore, nell'ipotesi che sia una struttura dati, corrisponde al primo campo. Viene poi salvato in \e{EAX} il valore memorizzato 4 bytes dopo l'indirizzo trovato, prendendo quindi il secondo campo della struttura dati, che deve essere un puntatore a funzione. Infine, mette sullo stack il valore di \e{ESI} per passarlo alla funzione che viene invocata. Il parametro passato contiene il risultato di \e{TlsGetValue}. Quando la funzione invocata termina, viene invocata la funzione \e{KERNEL32.DLL::LeaveCriticalSection}, passando come parametro il puntatore alla sezione critica. \bigskip

A questo punto, potrebbe essere necessario individuare la funzione che viene invocata in modo così "nascosto".







\subsection{FUN\_00401790\_print\_catched\_info}
\target{FUN\_00401790\_print\_catched\_info}
Per prima cosa, impostiamo il tipo del parametro della funzione a un \e{all_subkey_info_keeper} \e{*}.
Poi, per analizzare questa funzione, conviene guardare il decompilato: risulta infatti molto chiaro che questa funzione ha lo scopo di stampare tutto ciò che è stato precedentemente creato e salvato nella struttura dati passata come primo parametro. \\

\textbf{Approfondire}: capire perché nell'esecuzione sulla macchina virtuale queste info non vengono stampate.





\subsection{FUN\_00401010\_init\_func}
\target{FUN\_00401010\_init\_func}

Questa funzione era una label, memorizzata nella zona di memoria \e{DAT_0040700c+0x4}.\\
In questa funzione si inizializzano delle aree di memoria al valore 1.\\
Il flusso della funzione è determinato con dei confronti con \e{IMAGE_DOS_HEADER_00400000}. Sembra una funzione di inizializzazione: ci sono infatti chiamate a funzione di \e{MSVCRT.DLL:__set_app_type} che specifica se l'applicazione corrente è di tipo \e{_CONSOLE_APP} oppure \e{_GUI_APP}. Inoltre, si invoca \e{MSVCRT.DLL:__p__fmode}, che ritorna un puntatore alla variabile globale \e{_fmode}, la quale specifica la modalità di conversione di file predefinita per operazioni di I/O dei file. \\
Prima di ritornare, però, viene invocata la funzione \func{FUN_00402140} che prende in input l'indirizzo di un'altra funzione: la funzione \func{FUN_00401c30_math_error_routine}.


\subsection{FUN\_00402140\_store\_math\_error\_routine}
\target{FUN\_00402140\_store\_math\_error\_routine}
Questa funzione imposta il valore di una variabile globale all'indirizzo passato, e poi invoca la funzione \e{MSVCRT.DLL::__setusermatherr}. Questa funzione specifica una routine definita dall'utente per la gestione di errori matematici. Prende in input un parametro, ma nello stack non viene inserito nulla prima della sua invocazione: gli viene passata lo stesso parametro che ha ricevuto questa funzione, che infatti era un puntatore a funzione.

\subsection{FUN\_00401c30\_math\_error\_routine}
\target{FUN\_00401c30\_math\_error\_routine}
Questa funzione prende in input un parametro come puntatore a intero. Viene invocata l'istruzione
\begin{verbatim}
FLD qword ptr [EAX + 0x18]
\end{verbatim}
Con questa istruzione si salva l'operando nel \emph{register stack} \e{FPU}. \\

Nota: EAX attualmente punta al primo parametro, quindi a \e{ESP + 0x18}, cioè 6 indirizzi più avanti.\\

Si prepara l'invocazione della funzione \func{FUN_00402a00_get_file_pointer} mettendo sullo stack il valore 2 e, il suo valore di ritorno verrà utilizzato come primo parametro per l'invocazione di una \e{fprintf}: deve quindi ritornare un \e{FILE*}. Avendola invocata con parametro 2, verrà restituito lo \emph{stderr}. \\

Nota: sembra una funzione di log per errori matematici.\\

\subsection{FUN\_00402a00\_get\_file\_pointer}
\target{FUN\_00402a00\_get\_file\_pointer}

Questa funzione prende in input il primo parametro, lo moltiplica per 32 con uno \emph{shift left} di 5 posizioni e a questo valore somma il risultato di \e{MSVCRT.DLL::_iob}. Questa funzione restituisce l'array delle \emph{stdio control structures}, vale a dire un array di questo tipo:
\begin{verbatim}
{*stdin, *stdout, *stderr}
\end{verbatim}  
La funzione restituisce quindi il \emph{FILE *} indicizzato dal parametro in input.

\subsection{FUN\_00401120\_get\_main\_args}
\target{FUN\_00401120\_get\_main\_args}

Questa funzione invoca la funzione di libreria \e{MSVCRT.DLL::__getmainargs}, che prende in input 5 parametri. I parametri passati, sono tutti variabili globali e rappresentano, in ordine:
\begin{itemize}
\item L'intero \emph{argc}
\item La amtrice di stringe \emph{argv}
\item Una matrice di stringe \emph{\_env} che rappresenta le variabili impostate nell'ambiente dell'utente.
\item Un intero che, e impostato su 1, espande i caratteri jolly negli argomenti della riga di comando o, se impostato su 0, non esegue alcuna operazione.
\item Un puntatore a \emph{\_startupinfo}, che contiene altre informazioni da passare alla DLL CRT.
\end{itemize}
La cosa interessante, è che i primi due parametri sono passati in input anche alla funzione \func{FUN_00402a30_main}, che quindi è il nostro \emph{main}.








\newpage
\section{Note}
\begin{itemize}
\item Compilatore: Visualstudio:unknown
\item cambiato il tipo di DAT\_00405394 in dword: in entry c'è: 
\begin{verbatim}
	MOV dword ptr [DAT_00405394], 0x0
\end{verbatim}
\item l'indirizzo della funzione che inizializza il floating point unit è un multiplo di 8
\item in \func{FUN_00402480_critical_section_manager}, la funzione che fa lo scan dell'address space viene invocata se 
\begin{verbatim}
DAT_004053b4 != 0 && (param2 == 0 || param2 == 3)
\end{verbatim} 
Anche il \e{param_2} sembra un parametro di gestioni di sezioni critiche.
\item non trovo documentazione su \e{HKEY}, ma solo la sua definizione: \emph{Handle to Registry Key (HKEY) is a typedef supplied in the Windows headers files. A typedef can be thought of as an alias or pseudonym.}
\item creata per sbaglio una nuova categoria in data type manager che non riesco a eliminare

\end{itemize}
\attach{FUN\_00402480\_critical\_section\_manager}



\end{document}
